import json
import pprint

prop_groups = ['books', 'buildingblocks', 'chains', 'decoration', 'facade', 'foliage', 'furniture', 'gazebo',
               'lighting', '', 'statues', 'storage', 'study', 'fencing', '', '',
               '', '', 'backleaves', 'leaves', 'trunks', 'boulders', 'backdrops', 'temple',
               'npc', 'symbol', 'cars', 'sidewalk', 'machinery']

with open('sprite-data.json', 'rb') as f:
	prop_data = json.load(f)

output = [[] for _ in range(29)]
indices_output_data = [[] for _ in range(29)]

for set_index in prop_data:
	set_data = prop_data[set_index]
	
	for group_index in set_data:
		output_group = output[int(group_index)]
		indices_group = indices_output_data[int(group_index)]
		group_data = set_data[group_index]
		group_name = group_data['name']
		group_sprites = group_data['sprites']
		
		for sprite_index in group_sprites:
			sprite_data = group_sprites[sprite_index]
			x, y, w, h = sprite_data['bounds']
			rect_x, rect_y, rect_w, rect_h = sprite_data['palettes'][0][0]['rect']
			_, _, rect_uw, rect_uh = sprite_data['palettes'][0][0]['rect_uv']
			
			ox, oy = sprite_data['origin'] if 'origin' in sprite_data else (0.5, 0.5)
			ox = (ox * rect_w - x) / w
			oy = (oy * rect_h - y) / h
			
			x += rect_x
			y += rect_y
			
			palette_count = sprite_data['palette_count']
			name = sprite_data['name_nice']
			
			indices_group.append(f'\t\tPropIndex({set_index}, {group_index}, {sprite_index}, {palette_count}, "{name}"),\n')
			output_group.append(f'\t\tPropBounds({x}, {y}, {w}, {h}, {ox}, {oy}),\n')

		# pprint.pprint(output)

#
# Generate indices data
# ---------------------------------------------------

WARNING = '/* Auto generated by .scripts/gen_prop_data.py. Do not edit. */\n\n'

indices_group_output = WARNING + '''#include 'props.cpp';

class PropIndex
{
	
	uint set;
	uint group;
	uint index;
	uint palettes;
	string name;
	
	PropIndex() { }
	
	PropIndex(uint set, uint group, uint index, uint palettes, string name)
	{
		this.set = set;
		this.group = group;
		this.index = index;
		this.palettes = palettes;
		this.name = name;
	}
	
	string sprite_set_name()
	{
		return 'props' + set;
	}
	
	string sprite_name()
	{
		return PROP_GROUP_NAMES[group] + '_' + index;
	}
	
}

// Each item corresponds to a group defined in props.PROP_GROUP_NAMES
const array<array<PropIndex>> PROP_INDICES = {
'''

for i in range(len(indices_output_data)):
	indices_group = indices_output_data[i]
	
	if len(indices_group) == 0:
		indices_group_output += '\t{},\n'
		continue
	
	indices_group_str = ''.join(indices_group)
	group_name = prop_groups[i]
	
	indices_group_output += f'\t{{ // {group_name}\n{indices_group_str}\t}},\n'

indices_group_output += '};'

with open('../props_list.cpp', 'w') as f:
	f.write(indices_group_output)

#
# Generate bounds data
# ---------------------------------------------------

bounds_output = WARNING + '''class PropBounds
{

	float x;
	float y;
	float width;
	float height;
	float origin_x;
	float origin_y;

	PropBounds() { }

	PropBounds(float x, float y, float width, float height, float origin_x, float origin_y)
	{
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.origin_x = origin_x;
		this.origin_y = origin_y;
	}

}

// Each item corresponds to a group defined in props.PROP_GROUP_NAMES
const array<array<PropBounds>> PROP_BOUNDS = {
'''

for i in range(len(output)):
	bounds_group = output[i]

	if len(bounds_group) == 0:
		bounds_output += '\t{},\n'
		continue

	bounds_group_str = ''.join(bounds_group)
	group_name = prop_groups[i]

	bounds_output += f'\t{{ // {group_name}\n{bounds_group_str}\t}},\n'

bounds_output += '};'

with open('../props_bounds.cpp', 'w') as f:
	f.write(bounds_output)
